{"version":3,"sources":["js/selectionModel.ts"],"names":[],"mappings":"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","file":"selectionModel.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ISelectionRange } from './interfaces';\n\nexport class SelectionModel implements ISlickSelectionModel {\n\n    constructor(private _rowSelectionModel: ISlickSelectionModel,\n                private _handler: ISlickEventHandler,\n                private _onSelectedRangesChanged: ISlickEvent,\n                private _slickRangeFactory: (fromRow: number, fromCell: number, toRow: number, toCell: number) => Slick.Range) { }\n\n    get range(): Slick.Range[] {\n        return this._ranges;\n    }\n\n    get onSelectedRangesChanged(): ISlickEvent {\n        return this._onSelectedRangesChanged;\n    }\n\n    init(grid: ISlickGrid): void {\n        this._grid = grid;\n        this._rowSelectionModel.init(grid);\n        this._handler.subscribe(this._rowSelectionModel.onSelectedRangesChanged, (e, ranges) => {\n            this.updateSelectedRanges(ranges);\n        });\n    }\n\n    destroy(): void {\n        this._handler.unsubscribeAll();\n        this._rowSelectionModel.destroy();\n    }\n\n    setSelectedRanges(ranges: Slick.Range[]): void {\n        this._rowSelectionModel.setSelectedRanges(ranges);\n    }\n\n    getSelectedRanges(): Slick.Range[] {\n        return this._rowSelectionModel.getSelectedRanges();\n    }\n\n    changeSelectedRanges(selections: ISelectionRange[]): void {\n        let slickRange = (selections || []).map(s =>\n            this._slickRangeFactory(s.startRow, s.startColumn, s.endRow - 1, s.endColumn - 1)\n        );\n        this.updateSelectedRanges(slickRange);\n    }\n\n    toggleSingleColumnSelection(columnId: string): void {\n        let newRanges = [this.getColumnRange(columnId)];\n        if (SelectionModel.areRangesIdentical(newRanges, this._ranges)) {\n            this.clearSelection();\n        } else {\n            this.setSingleColumnSelection(columnId);\n        }\n    }\n\n    setSingleColumnSelection(columnId: string): void {\n        this._lastSelectedColumnIndexSequence = [this._grid.getColumnIndex(columnId)];\n        this._grid.resetActiveCell();\n        this.updateSelectedRanges([this.getColumnRange(columnId)]);\n    }\n\n    toggleMultiColumnSelection(columnId: string): void {\n        if (this.isColumnSelectionCurrently === false) {\n            return this.toggleSingleColumnSelection(columnId);\n        }\n        let columnIndex = this._grid.getColumnIndex(columnId);\n        let columnRange = this.getColumnRangeByIndex(columnIndex);\n        let columnInRange = false;\n        let newRanges = this._ranges.filter((value, index) => {\n            if (value.fromCell === columnRange.fromCell && value.toCell === columnRange.toCell) {\n                columnInRange = true;\n                return false;\n            }\n            return true;\n        });\n        this._lastSelectedColumnIndexSequence = this._lastSelectedColumnIndexSequence.filter(value => value !== columnIndex);\n\n        if (columnInRange === false) {\n            newRanges.push(columnRange);\n            this._lastSelectedColumnIndexSequence.push(this._grid.getColumnIndex(columnId));\n        }\n\n        this._grid.resetActiveCell();\n        this.updateSelectedRanges(newRanges);\n    }\n\n    extendMultiColumnSelection(columnId: string): void {\n        if (this.isColumnSelectionCurrently === false\n            || !this._lastSelectedColumnIndexSequence\n            || this._lastSelectedColumnIndexSequence.length === 0) {\n            return this.toggleSingleColumnSelection(columnId);\n        }\n\n        let columnIndex = this._grid.getColumnIndex(columnId);\n        let lastSelectedColumnIndex = this._lastSelectedColumnIndexSequence[this._lastSelectedColumnIndexSequence.length - 1];\n\n        let start = Math.min(columnIndex, lastSelectedColumnIndex);\n        let end = Math.max(columnIndex, lastSelectedColumnIndex);\n\n        let newRanges = [];\n        this._lastSelectedColumnIndexSequence = [];\n        for (let i = start; i <= end; i++) {\n            newRanges.push(this.getColumnRangeByIndex(i));\n            if (i !== lastSelectedColumnIndex) {\n                this._lastSelectedColumnIndexSequence.push(i);\n            }\n        }\n        this._lastSelectedColumnIndexSequence.push(lastSelectedColumnIndex);\n\n        this._grid.resetActiveCell();\n        this.updateSelectedRanges(newRanges);\n    }\n\n    clearSelection(): void {\n        this._lastSelectedColumnIndexSequence = [];\n        this._grid.resetActiveCell();\n        this._rowSelectionModel.setSelectedRanges([]);\n    }\n\n    private _grid: ISlickGrid;\n    private _ranges: Slick.Range[] = [];\n    private _lastSelectedColumnIndexSequence: number[] = [];\n\n    private static areRangesIdentical(lhs: Slick.Range[], rhs: Slick.Range[]): boolean {\n        if (lhs && rhs && (lhs !== rhs) && lhs.length === rhs.length) {\n            for (let i = 0; i < lhs.length; ++i) {\n                if (lhs[i].fromRow !== rhs[i].fromRow\n                    || lhs[i].toRow !== rhs[i].toRow\n                    || lhs[i].fromCell !== rhs[i].fromCell\n                    || lhs[i].toCell !== rhs[i].toCell) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    private getColumnRange(columnId: string): Slick.Range {\n        let columnIndex = this._grid.getColumnIndex(columnId);\n        return this.getColumnRangeByIndex(columnIndex);\n    }\n\n    private getColumnRangeByIndex(columnIndex: number): Slick.Range {\n        let rowCount = this._grid.getDataLength();\n        let lastRowToSelect =  rowCount === 0 ? 0 : rowCount - 1 ;\n        return this._slickRangeFactory(0, columnIndex, lastRowToSelect, columnIndex);\n    }\n\n    private get isColumnSelectionCurrently(): boolean {\n        return this._ranges\n            && this._ranges.length > 0\n            && this._ranges.find(r => {\n                let startAtFirstRow = r.fromRow === 0;\n                let endAtLastRow = r.toRow === Math.max(0, this._grid.getDataLength() - 1);\n                return !startAtFirstRow || !endAtLastRow || r.fromCell !== r.toCell;\n            }) === undefined;\n    }\n\n    private updateSelectedRanges(ranges: Slick.Range[]): void {\n        // Set focus to this grid if it's not already somewhere inside it.\n        if (ranges && ranges.length !== 0 && this._grid && this._grid.getCanvasNode() && !this._grid.getCanvasNode().contains(document.activeElement)) {\n            this._grid.focus();\n        }\n\n        if (SelectionModel.areRangesIdentical(ranges, this._ranges)) {\n            return;\n        }\n\n        this._ranges = ranges;\n        this.onSelectedRangesChanged.notify(this._ranges);\n    }\n}\n\nexport interface ISlickSelectionModel {\n    range: Slick.Range[];\n    onSelectedRangesChanged: any;\n    init(grid: any): void;\n    destroy(): void;\n    setSelectedRanges(ranges: Slick.Range[]): void;\n    getSelectedRanges(): Slick.Range[];\n}\n\nexport interface ISlickEventHandler {\n    subscribe(event: any, handler: any): void;\n    unsubscribeAll(): void;\n}\n\nexport interface ISlickEvent {\n    notify(eventData: Slick.Range[]): void;\n    subscribe(handler: (e: any, args: any) => void): void;\n}\n\nexport interface ISlickGrid {\n    getActiveCellNode(): any;\n    getCanvasNode(): any;\n    resetActiveCell(): void;\n    focus(): void;\n    getColumnIndex(columnId: string): number;\n    getDataLength(): number;\n}\n"]}